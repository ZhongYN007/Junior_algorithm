### LeetCode 初级算法

## 第一题

### 题目：

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

作者：力扣 (LeetCode)

### 思路：

重点在于：有序数组，那么就是说大小是排好顺序的,也就是说重复元素是连续的（但是我现在只会三个for循环暴力破解），连续在我看来应该是时间复杂度降低的突破口

现在写个最简单的代码，以后有突破再改。



### 代码1

这个代码就不详解了，太简单了

*nums是数组，numsSize是数组长度

```c++
int removeDuplicates(int* nums, int numsSize)
{
​    for(int i=0;i<numsSize;i++)
​    {
​     for(int j=i+1;j<numsSize;j++)
​      {
​        if(nums[i]==nums[j])
​        {
​            for(int k=j;k<numsSize-1;k++)
​            {
​                nums[k]=nums[k+1];
​            }//for
​            numsSize--;
​            j=i;
​        }//if
​     }//for
​    }//for
​    return numsSize;
}
```

## 第二题

### 题目：

买卖股票的最佳时机 II
给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 示例 1:

输入: prices = [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
示例 2:

输入: prices = [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

作者：力扣 (LeetCode)

### 思路：

  经过某钟姓同学的传授，找到一种还算不错的办法（但是想法和我的差不多）：用后一个数字减去前一个数字，如果相减后的数组中的元素为正，加入总和中，若为负数，则不加

  注意：相减后数组中的第一个数字是不能加入总和的，因为第一天只能买入无法卖出，是没有收益的。

  虽然方法可行，但是依旧不是最优算法，仍然需要改进：

  执行用时：12 ms, 在所有 C 提交中击败了23.83%的用户

  内存消耗：6.5 MB, 在所有 C 提交中击败了95.07%的用户

  通过测试用例：200 / 200

### 代码：

```c
int maxProfit(int* prices, int pricesSize){
    int count=0;
for(int i=pricesSize-1;i>0;i--)
{
    prices[i]=prices[i]-prices[i-1];
}
for(int j=pricesSize-1;j>0;j--)
{
    if(prices[j]>0)
    count+=prices[j];
}
return count;
}
```

## 第三题

### 题目：

旋转数组
给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。

 示例 1:

输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]

作者：力扣 (LeetCode)

### 思路：

其实这个题在大一是写过的，但是算法时间复杂度高，是O（n^2），没什么难度，不讲解，如下：

```c
void rotate(int* nums, int numsSize, int k){
 for(int i=0;i<k;i++)
 {
     int t=nums[numsSize-1];

     for(int j=numsSize-1;j>0;j--)
     nums[j]=nums[j-1];

     nums[0]=t;

 }//for
}

```

在看了别人的提示后，发现了另一种，可以将时间复杂度降低到O(n):

  1、构建一个数组，把原来的数组给复制到这个动态开辟的数组中。

  2、通过算法，把新数组中的数据再次移到原来的数组中。

重要步骤：

使用`(i + k) % length`来计算重新赋值的元素下标

### 代码：

```c
void rotate(int* nums, int numsSize, int k){
 int length=numsSize;
 int*temp=(int*)malloc(length*sizeof(int));
 for(int i=0;i<length;i++)
 temp[i]=nums[i];
 for(int j=0;j<length;j++)
 nums[(j+k)%length]=temp[j]; 
}
```

执行用时：96 ms, 在所有 C 提交中击败了98.83%的用户

内存消耗：22.3 MB, 在所有 C 提交中击败了5.04%的用户

通过测试用例：38 / 38

## 第四题





